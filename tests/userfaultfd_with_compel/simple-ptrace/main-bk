#define _POSIX_C_SOURCE 200112L

/* C standard library */
#include <errno.h>		// errno
#include <stdio.h>		// pid_t
#include <stddef.h>
#include <stdlib.h>		// EXIT_FAILURE
#include <string.h>

/* POSIX */
#include <unistd.h>
#include <signal.h>		// SIGTRAP
#include <sys/user.h>	// struct user_regs_struct
#include <sys/wait.h>
#include <time.h>		// struct timespec, clock_gettime()

/* Linux */
#include <syscall.h>
#include <sys/ptrace.h>

#include <linux/ptrace.h>
#include <sys/reg.h>	// ORIG_RAX

#include "ptrace.h"
#include "log.h"		// log printing
#include "compel_extension.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include<fcntl.h>



/* Time measuring. */
struct timespec tstart={0,0}, tend={0,0};
static int check_pipe_ends(int wfd, int rfd)
{
        struct stat r, w;
        char aux[2048] = "";

        printf("Check pipe ends are at hands\n");
        if (fstat(wfd, &w) < 0) {
                perror("Can't stat wfd");
                return 0;
        }

        if (fstat(rfd, &r) < 0) {
                perror("Can't stat rfd");
                return 0;
        }

        if (w.st_dev != r.st_dev || w.st_ino != r.st_ino) {
                perror("Pipe's not the same");
                return 0;
        }

        printf("Check pipe ends are connected\n");
        if (write(wfd, "1", 2) != 2) {
                fprintf(stderr, "write to pipe failed\n");
                return -1;
        }
        /*if (read(rfd, aux, sizeof(aux)) != sizeof(aux)) {
                fprintf(stderr, "read from pipe failed\n");
                return -1;
        }*/

        int read_bytes = 0;
        while((read_bytes = read(rfd, aux, sizeof(aux))) > 0){
            printf("%s",aux);
            if(read_bytes != 2048){
                break;
            }
        }
/*
        if (aux[0] != '1' || aux[1] != '\0') {
                fprintf(stderr, "Pipe connectivity lost\n");
                return 0;
        }
*/
        return 1;
}


/**
 * Main function for the simple ptrace monitor
 * Use: ./monitor <executable> <args>
 * */
int main(int argc, char **argv)
{
	if (argc <= 1)
	    log_error("too few arguments: %d", argc);

	clock_gettime(CLOCK_MONOTONIC, &tstart);
	pid_t pid = vfork();
        
        int pipe_out[2];
        if(pipe(pipe_out)){
            fprintf(stderr,"Can't make pipe");
            return -1;
        }

	switch (pid) {
		case -1: /* error */
			log_error("%s. pid -1", strerror(errno));
		case 0:  /* child, executing the tracee */
			//ptrace(PTRACE_TRACEME, 0, 0, 0);
                        close(pipe_out[0]);
                        dup2(pipe_out[1],1);
                        close(pipe_out[1]);
			execl(argv[1], argv + 1, NULL);
                        exit(1);
			log_error("%s. child", strerror(errno));
	}
 
        close(pipe_out[1]);
        compel_setup(pid);
        int child_stdout_fd; 
        steal_fd(PARASITE_CMD_GET_STDOUT_FD, &child_stdout_fd);
        printf("fd: %d\n", child_stdout_fd);
        compel_destruct(pid);    
        wait(NULL);

        check_pipe_ends(child_stdout_fd, pipe_out[0]);
#if 0
        //dup2(child_stdout_fd, 1);
        int read_bytes = 0;
        char aux[2048] = "";
        while((read_bytes = read(pipe_out[0], aux, sizeof(aux))) > 0){ 
            printf("%s",aux);
            if(read_bytes != 2048){
                break;
            }
        }
#endif    

        
        //waitpid(pid, 0, 0);	// sync with PTRACE_TRACEME

/* 
	ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_EXITKILL);

	int terminate = 0;
	int status = 0;
	while (!terminate) {
		//uint64_t pc = get_pc(pid);
		//log_info("pc: 0x%lx", pc);
		//status = 0;
		ptrace(PTRACE_CONT, pid, 0L, 0L);
		if (waitpid(pid, &status, 0) == -1) {
			log_info("status %d", status);
			if (WIFEXITED(status))
				log_info("Child terminated normally.");
			break;
		}
	}
*/
	clock_gettime(CLOCK_MONOTONIC, &tend);
	log_info("Finish main loop! %.5f seconds.", ((double)tend.tv_sec + 1.0e-9*tend.tv_nsec) - 
           ((double)tstart.tv_sec + 1.0e-9*tstart.tv_nsec));

	return 0;
}
